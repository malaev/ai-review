import { Octokit } from '@octokit/rest';
import * as dotenv from 'dotenv';
import fetch from 'node-fetch';

// –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
dotenv.config();

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY;
const GITHUB_REPOSITORY = process.env.GITHUB_REPOSITORY;
const GITHUB_EVENT_NAME = process.env.GITHUB_EVENT_NAME;
let PR_NUMBER: string | undefined;

if (!GITHUB_TOKEN) {
  throw new Error('GITHUB_TOKEN is required');
}

if (!DEEPSEEK_API_KEY) {
  throw new Error('DEEPSEEK_API_KEY is required');
}

if (!GITHUB_REPOSITORY) {
  throw new Error('GITHUB_REPOSITORY is required');
}

const [owner, repo] = GITHUB_REPOSITORY.split('/');

// PR_NUMBER —Ç—Ä–µ–±—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–æ–±—ã—Ç–∏—è pull_request
if (GITHUB_EVENT_NAME === 'pull_request') {
  PR_NUMBER = process.env.PR_NUMBER;
  if (!PR_NUMBER) {
    throw new Error('PR_NUMBER is required for pull_request events');
  }
}

const octokit = new Octokit({
  auth: GITHUB_TOKEN,
});

const DEEPSEEK_API_URL = 'https://api.deepseek.com/v1/chat/completions';

// –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –¥–ª—è API –∑–∞–ø—Ä–æ—Å–æ–≤
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;

interface PullRequestInfo {
  owner: string;
  repo: string;
  pull_number: number;
}

interface CodeAnalysis {
  quality: string[];
  security: string[];
  performance: string[];
}

interface DeepSeekResponse {
  choices: Array<{
    message: {
      content: string;
    };
  }>;
}

interface ConversationContext {
  filePath: string;
  lineStart: number;
  lineEnd: number;
  code: string;
  messages: Array<{
    role: 'user' | 'assistant';
    content: string;
  }>;
}

interface ReviewComment {
  path: string;
  line: number;
  body: string;
}

interface AnalysisIssue {
  line: number;
  type: 'quality' | 'security' | 'performance';
  description: string;
}

interface AnalysisResponse {
  issues: AnalysisIssue[];
}

// –•—Ä–∞–Ω–∏–ª–∏—â–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤ –æ–±—Å—É–∂–¥–µ–Ω–∏–π
const conversationContexts = new Map<string, ConversationContext>();

// –£—Ç–∏–ª–∏—Ç–∞ –¥–ª—è –∑–∞–¥–µ—Ä–∂–∫–∏
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// –£—Ç–∏–ª–∏—Ç–∞ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫
async function withRetry<T>(operation: () => Promise<T>, retries = MAX_RETRIES): Promise<T> {
  try {
    return await operation();
  } catch (error) {
    if (retries > 0) {
      console.log(`–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ (–æ—Å—Ç–∞–ª–æ—Å—å ${retries})...`);
      await delay(RETRY_DELAY);
      return withRetry(operation, retries - 1);
    }
    throw error;
  }
}

function chunkDiff(diff: string, maxChunkSize: number = 4000): string[] {
  if (!diff) {
    throw new Error('Diff is empty');
  }

  const lines = diff.split('\n');
  const chunks: string[] = [];
  let currentChunk: string[] = [];
  let currentSize = 0;

  for (const line of lines) {
    if (currentSize + line.length > maxChunkSize && currentChunk.length > 0) {
      chunks.push(currentChunk.join('\n'));
      currentChunk = [];
      currentSize = 0;
    }
    currentChunk.push(line);
    currentSize += line.length;
  }

  if (currentChunk.length > 0) {
    chunks.push(currentChunk.join('\n'));
  }

  return chunks;
}

async function getDiff({ owner, repo, pull_number }: PullRequestInfo): Promise<string> {
  const response = await withRetry(() => octokit.pulls.get({
    owner,
    repo,
    pull_number,
    mediaType: {
      format: 'diff',
    },
  }));

  if (typeof response.data === 'string') {
    return response.data;
  }

  throw new Error('Failed to get diff in correct format');
}

async function getCommentContext(owner: string, repo: string, comment_id: number): Promise<ConversationContext | null> {
  try {
    const { data: comment } = await withRetry(() => octokit.issues.getComment({
      owner,
      repo,
      comment_id,
    }));

    if (!comment?.body) {
      console.log('Comment body is empty');
      return null;
    }

    const prNumber = comment.issue_url.split('/').pop();
    if (!prNumber) {
      console.log('Could not extract PR number from URL');
      return null;
    }

    const { data: pr } = await withRetry(() => octokit.pulls.get({
      owner,
      repo,
      pull_number: parseInt(prNumber, 10),
    }));

    const contextKey = `${pr.number}-${comment_id}`;
    let context = conversationContexts.get(contextKey);

    if (!context) {
      const codeMatch = comment.body.match(/\`\`\`[\s\S]*?\`\`\`/);
      if (codeMatch) {
        context = {
          filePath: 'unknown',
          lineStart: 0,
          lineEnd: 0,
          code: codeMatch[0],
          messages: [{
            role: 'assistant',
            content: comment.body,
          }],
        };
        conversationContexts.set(contextKey, context);
      }
    }

    return context || null;
  } catch (error) {
    console.error('Error getting comment context:', error);
    return null;
  }
}

async function analyzeCodeWithDeepSeek(chunk: string, context?: ConversationContext): Promise<string> {
  if (!chunk) {
    throw new Error('Empty chunk provided for analysis');
  }

  const systemPrompt = context
    ? `–í—ã —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫–æ–¥–∞ –¥–ª—è React + TypeScript –ø—Ä–æ–µ–∫—Ç–æ–≤. –í—ã —É—á–∞—Å—Ç–≤—É–µ—Ç–µ –≤ –æ–±—Å—É–∂–¥–µ–Ω–∏–∏ –∫–æ–¥–∞. 
       –ö–æ–Ω—Ç–µ–∫—Å—Ç –æ–±—Å—É–∂–¥–µ–Ω–∏—è:
       –§–∞–π–ª: ${context.filePath}
       –°—Ç—Ä–æ–∫–∏: ${context.lineStart}-${context.lineEnd}
       –ö–æ–¥:
       ${context.code}
       
       –ü—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è:
       ${context.messages.map(m => `${m.role}: ${m.content}`).join('\n')}
       
       –û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —É—á–∏—Ç—ã–≤–∞—è –≤–µ—Å—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –æ–±—Å—É–∂–¥–µ–Ω–∏—è.`
    : `–í—ã —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫–æ–¥–∞ –¥–ª—è React + TypeScript –ø—Ä–æ–µ–∫—Ç–æ–≤. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —Å–ª–µ–¥—É—é—â–∏–π diff –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—å—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ç–∑—ã–≤ –ø–æ —Ç—Ä–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º:
       1. –ö–∞—á–µ—Å—Ç–≤–æ –∫–æ–¥–∞ (—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ, —á–∏—Ç–∞–µ–º–æ—Å—Ç—å, —Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –ª—É—á—à–∏–º –ø—Ä–∞–∫—Ç–∏–∫–∞–º, –Ω–∞–ª–∏—á–∏–µ —Ç–∏–ø–∏–∑–∞—Ü–∏–∏)
       2. –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å (—É—è–∑–≤–∏–º–æ—Å—Ç–∏, –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö, –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è)
       3. –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ React, —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º, –º–µ–º–æ–∏–∑–∞—Ü–∏—è, –æ—à–∏–±–∫–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ö—É–∫–æ–≤)
       
       –§–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –≤–∏–¥–µ JSON:
       {
         "quality": ["–ø—É–Ω–∫—Ç 1", "–ø—É–Ω–∫—Ç 2", ...],
         "security": ["–ø—É–Ω–∫—Ç 1", "–ø—É–Ω–∫—Ç 2", ...],
         "performance": ["–ø—É–Ω–∫—Ç 1", "–ø—É–Ω–∫—Ç 2", ...]
       }`;

  const response = await withRetry(() => fetch(DEEPSEEK_API_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
    },
    body: JSON.stringify({
      model: 'deepseek-chat',
      messages: [
        {
          role: 'system',
          content: systemPrompt,
        },
        {
          role: 'user',
          content: chunk,
        },
      ],
      response_format: context ? undefined : { type: 'json_object' },
      temperature: 0.3,
      max_tokens: 2000,
    }),
  }));

  if (!response.ok) {
    throw new Error(`DeepSeek API error: ${response.statusText}`);
  }

  const data = await response.json() as DeepSeekResponse;
  if (!data.choices?.[0]?.message?.content) {
    throw new Error('Invalid response from DeepSeek API');
  }

  return data.choices[0].message.content;
}

async function analyzeFile(file: { filename: string, patch?: string }, prInfo: PullRequestInfo): Promise<ReviewComment[]> {
  // –ü–æ–ª—É—á–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞
  const { data: fileContent } = await withRetry(() => octokit.repos.getContent({
    owner: prInfo.owner,
    repo: prInfo.repo,
    path: file.filename,
    ref: `pull/${prInfo.pull_number}/head`,
  }));

  if (!('content' in fileContent)) {
    throw new Error('File content not found');
  }

  const content = Buffer.from(fileContent.content, 'base64').toString();

  const systemPrompt = `–í—ã –æ–ø—ã—Ç–Ω—ã–π —Ä–µ–≤—å—é–µ—Ä React + TypeScript –ø—Ä–æ–µ–∫—Ç–æ–≤.
    –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –∫–æ–¥ –∏ –Ω–∞–π–¥–∏—Ç–µ —Ç–æ–ª—å–∫–æ —Å–µ—Ä—å–µ–∑–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –±–∞–≥–∞–º –∏–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞–º —Å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é.
    
    –ù–ï –ù–£–ñ–ù–û –∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å:
    - –°—Ç–∏–ª–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã
    - –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —Ç–∏–ø–æ–≤ —Ç–∞–º, –≥–¥–µ –æ–Ω–∏ –æ—á–µ–≤–∏–¥–Ω—ã –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
    - –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ console.log
    - –ú–µ–ª–∫–∏–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –ª–∏–Ω—Ç–µ—Ä–∞
    - –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
    - –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞
    
    –°—Ñ–æ–∫—É—Å–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞:
    - –£—Ç–µ—á–∫–∞—Ö –ø–∞–º—è—Ç–∏
    - –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ React —Ö—É–∫–æ–≤
    - –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö race conditions
    - –ü—Ä–æ–±–ª–µ–º–∞—Ö –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    - –°–µ—Ä—å–µ–∑–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º–∞—Ö –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    - –õ–æ–≥–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–∫–∞—Ö –≤ –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–µ
    
    –î–ª—è –∫–∞–∂–¥–æ–π –Ω–∞–π–¥–µ–Ω–Ω–æ–π –ø—Ä–æ–±–ª–µ–º—ã —É–∫–∞–∂–∏—Ç–µ:
    1. –ù–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏ (line)
    2. –¢–∏–ø –ø—Ä–æ–±–ª–µ–º—ã (type: 'quality' | 'security' | 'performance')
    3. –û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã (description)
    
    –í–ê–ñ–ù–û: –û—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å—Ç—Ä–æ–≥–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–æ—è—Å–Ω–µ–Ω–∏–π:
    {
      "issues": [
        {
          "line": number,
          "type": "quality" | "security" | "performance",
          "description": "string"
        }
      ]
    }`;

  const response = await withRetry(() => fetch(DEEPSEEK_API_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
    },
    body: JSON.stringify({
      model: 'deepseek-chat',
      messages: [
        {
          role: 'system',
          content: systemPrompt,
        },
        {
          role: 'user',
          content: content,
        },
      ],
      response_format: { type: 'json_object' },
      temperature: 0.3,
      max_tokens: 4000,
    }),
  }));

  if (!response.ok) {
    throw new Error(`DeepSeek API error: ${response.statusText}`);
  }

  const data = await response.json() as { choices: [{ message: { content: string } }] };
  let analysis;

  try {
    analysis = JSON.parse(data.choices[0].message.content) as AnalysisResponse;
  } catch (error) {
    console.error('Failed to parse DeepSeek response:', error);
    console.log('Raw response:', data.choices[0].message.content);
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
    return [];
  }

  if (!analysis.issues || !Array.isArray(analysis.issues)) {
    console.error('Invalid analysis format:', analysis);
    return [];
  }

  return analysis.issues
    .filter((issue): issue is AnalysisIssue =>
      typeof issue.line === 'number' &&
      typeof issue.type === 'string' &&
      typeof issue.description === 'string'
    )
    .map(issue => ({
      path: file.filename,
      line: issue.line,
      body: `### ${issue.type === 'quality' ? 'üìù' : issue.type === 'security' ? 'üîí' : '‚ö°'} ${issue.type.charAt(0).toUpperCase() + issue.type.slice(1)}\n${issue.description}`
    }));
}

interface GitHubError extends Error {
  status?: number;
}

async function commentOnPR(prInfo: PullRequestInfo) {
  // –ü–æ–ª—É—á–∞–µ–º —Ñ–∞–π–ª—ã, –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–µ –≤ PR
  const { data: files } = await withRetry(() => octokit.pulls.listFiles({
    owner: prInfo.owner,
    repo: prInfo.repo,
    pull_number: prInfo.pull_number,
  }));

  // –ü–æ–ª—É—á–∞–µ–º diff –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ñ–∞–π–ª–∞
  const { data: pr } = await withRetry(() => octokit.pulls.get({
    owner: prInfo.owner,
    repo: prInfo.repo,
    pull_number: prInfo.pull_number,
  }));

  // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π —Ñ–∞–π–ª –∏ —Å–æ–±–∏—Ä–∞–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
  const allComments = await Promise.all(
    files
      .filter(file => file.filename.match(/\.(ts|tsx|js|jsx)$/))
      .map(file => analyzeFile(file, prInfo))
  );

  // –§–∏–ª—å—Ç—Ä—É–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏, –æ—Å—Ç–∞–≤–ª—è—è —Ç–æ–ª—å–∫–æ —Ç–µ, –∫–æ—Ç–æ—Ä—ã–µ –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–º —Å—Ç—Ä–æ–∫–∞–º
  const validComments = allComments.flat().filter(comment => {
    const file = files.find(f => f.filename === comment.path);
    if (!file || !file.patch) return false;

    // –ü–∞—Ä—Å–∏–º diff —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
    const changedLines = new Set<number>();
    const diffLines = file.patch.split('\n');
    let currentLine = 0;

    for (const line of diffLines) {
      if (line.startsWith('@@')) {
        const match = line.match(/@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@/);
        if (match) {
          currentLine = parseInt(match[1], 10) - 1;
        }
        continue;
      }

      if (line.startsWith('+')) {
        changedLines.add(currentLine);
      }
      if (!line.startsWith('-')) {
        currentLine++;
      }
    }

    return changedLines.has(comment.line);
  });

  if (validComments.length === 0) {
    console.log('No valid comments to create');
    return;
  }

  // –°–æ–∑–¥–∞–µ–º —Ä–µ–≤—å—é —Ç–æ–ª—å–∫–æ —Å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏ –∫ –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–º —Å—Ç—Ä–æ–∫–∞–º
  try {
    const { data: review } = await withRetry(() => octokit.pulls.createReview({
      owner: prInfo.owner,
      repo: prInfo.repo,
      pull_number: prInfo.pull_number,
      event: 'COMMENT',
      comments: validComments,
    }));
    console.log(`Created review: ${review.html_url}`);
  } catch (error: unknown) {
    const githubError = error as GitHubError;
    if (githubError.status === 422) {
      console.error('Failed to create review. Some comments might be outside of the diff.');
      console.log('Valid comments:', validComments);
    } else {
      throw error;
    }
  }
}

function formatAnalysisComment(analysis: CodeAnalysis): string {
  if (!analysis.quality?.length && !analysis.security?.length && !analysis.performance?.length) {
    return `## ü§ñ AI Code Review

–ö–æ–¥ –≤—ã–≥–ª—è–¥–∏—Ç —Ö–æ—Ä–æ—à–æ! –Ø –Ω–µ –Ω–∞—à–µ–ª —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º.

---
*–≠—Ç–æ—Ç –æ—Ç–∑—ã–≤ –±—ã–ª —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å –ø–æ–º–æ—â—å—é AI Code Review.*`;
  }

  return `## ü§ñ AI Code Review

${analysis.quality.length ? `### üìù –ö–∞—á–µ—Å—Ç–≤–æ –∫–æ–¥–∞
${analysis.quality.map(item => `- ${item}`).join('\n')}` : ''}

${analysis.security.length ? `### üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å
${analysis.security.map(item => `- ${item}`).join('\n')}` : ''}

${analysis.performance.length ? `### ‚ö° –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
${analysis.performance.map(item => `- ${item}`).join('\n')}` : ''}

---
*–≠—Ç–æ—Ç –æ—Ç–∑—ã–≤ –±—ã–ª —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å –ø–æ–º–æ—â—å—é AI Code Review.*`;
}

async function handlePRReview(prInfo: PullRequestInfo) {
  console.log(`–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é PR #${prInfo.pull_number}...`);

  console.log('–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Ñ–∞–π–ª—ã –∏ –æ—Å—Ç–∞–≤–ª—è—é –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏...');
  await commentOnPR(prInfo);
  console.log('–ì–æ—Ç–æ–≤–æ!');
}

async function handleCommentReply(owner: string, repo: string, comment_id: number, reply_to_id: number) {
  console.log(`–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –æ—Ç–≤–µ—Ç –Ω–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π ${reply_to_id}...`);

  // –ü–æ–ª—É—á–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–≤–µ—á–∞–µ–º
  const { data: originalComment } = await withRetry(() => octokit.issues.getComment({
    owner,
    repo,
    comment_id: reply_to_id,
  }));

  // –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å –≤–æ–ø—Ä–æ—Å–æ–º
  const { data: newComment } = await withRetry(() => octokit.issues.getComment({
    owner,
    repo,
    comment_id,
  }));

  if (!originalComment?.body || !newComment?.body) {
    console.error('Comment body is empty');
    return;
  }

  // –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è (—Ç–∏–ø –ø—Ä–æ–±–ª–µ–º—ã –∏ –æ–ø–∏—Å–∞–Ω–∏–µ)
  const typeMatch = originalComment.body.match(/### (üìù|üîí|‚ö°) (Quality|Security|Performance)/i);
  const type = typeMatch ? typeMatch[2].toLowerCase() : 'quality';

  // –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ–º–ø—Ç —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
  const systemPrompt = `–í—ã —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫–æ–¥–∞ –¥–ª—è React + TypeScript –ø—Ä–æ–µ–∫—Ç–æ–≤.
    –í—ã –æ—Å—Ç–∞–≤–∏–ª–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ –ø—Ä–æ–±–ª–µ–º–µ —Ç–∏–ø–∞ "${type}" –≤ –∫–æ–¥–µ.
    
    –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:
    ${originalComment.body}
    
    –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–¥–∞–ª –≤–æ–ø—Ä–æ—Å:
    ${newComment.body}
    
    –û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ –≤–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø—Ä–æ–±–ª–µ–º—ã –≤ –∫–æ–¥–µ.
    –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π, –Ω–æ –ø–æ–Ω—è—Ç–Ω—ã–π —è–∑—ã–∫.
    –ï—Å–ª–∏ –Ω—É–∂–Ω–æ, –ø—Ä–µ–¥–ª–æ–∂–∏—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã.`;

  console.log('–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –≤–æ–ø—Ä–æ—Å...');
  const response = await withRetry(() => fetch(DEEPSEEK_API_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
    },
    body: JSON.stringify({
      model: 'deepseek-chat',
      messages: [
        {
          role: 'system',
          content: systemPrompt,
        },
        {
          role: 'user',
          content: newComment.body,
        },
      ],
      temperature: 0.3,
      max_tokens: 2000,
    }),
  }));

  if (!response.ok) {
    throw new Error(`DeepSeek API error: ${response.statusText}`);
  }

  const data = await response.json() as DeepSeekResponse;
  const answer = data.choices[0].message.content;

  const issueNumber = newComment.issue_url.split('/').pop();
  if (!issueNumber) {
    throw new Error('Could not extract issue number from URL');
  }

  console.log('–û—Ç–ø—Ä–∞–≤–ª—è—é –æ—Ç–≤–µ—Ç...');
  await withRetry(() => octokit.issues.createComment({
    owner,
    repo,
    issue_number: parseInt(issueNumber, 10),
    body: answer,
  }));

  console.log('–ì–æ—Ç–æ–≤–æ!');
}

async function main() {
  const [owner, repo] = GITHUB_REPOSITORY?.split('/') || [];
  const eventName = process.env.GITHUB_EVENT_NAME;

  if (!owner || !repo) {
    throw new Error('Missing repository information');
  }

  try {
    if (eventName === 'pull_request') {
      const pull_number = Number(PR_NUMBER);
      if (isNaN(pull_number)) {
        throw new Error(`Invalid PR number: ${PR_NUMBER}`);
      }
      await handlePRReview({ owner, repo, pull_number });
    } else if (eventName === 'issue_comment') {
      const comment_id = Number(process.env.COMMENT_ID);
      const reply_to_id = Number(process.env.REPLY_TO_ID);
      if (!comment_id || !reply_to_id) {
        throw new Error('Missing comment information');
      }
      await handleCommentReply(owner, repo, comment_id, reply_to_id);
    } else {
      throw new Error(`Unsupported event type: ${eventName}`);
    }
  } catch (error) {
    console.error('Error during code review:', error);
    process.exit(1);
  }
}

main(); 